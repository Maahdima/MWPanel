// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
)

const createPeer = `-- name: CreatePeer :one
INSERT INTO wg_peers (
                peer_id,
                disabled,
                comment,
                peer_name,
                public_key,
                interface,
                allowed_address,
                endpoint,
                endpoint_port,
                persistent_keepalive,
                scheduler_id,
                queue_id,
                expire_time,
                traffic_limit,
                download_bandwidth,
                upload_bandwidth
            ) VALUES (
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?,
                ?
            )
RETURNING id, peer_id, disabled, comment, peer_name, public_key, interface, allowed_address, endpoint, endpoint_port, persistent_keepalive, scheduler_id, queue_id, expire_time, traffic_limit, download_bandwidth, upload_bandwidth, download_usage, upload_usage
`

type CreatePeerParams struct {
	PeerID              string
	Disabled            string
	Comment             *string
	PeerName            string
	PublicKey           string
	Interface           string
	AllowedAddress      string
	Endpoint            string
	EndpointPort        string
	PersistentKeepalive string
	SchedulerID         *string
	QueueID             *string
	ExpireTime          *string
	TrafficLimit        *string
	DownloadBandwidth   *string
	UploadBandwidth     *string
}

func (q *Queries) CreatePeer(ctx context.Context, arg CreatePeerParams) (WgPeer, error) {
	row := q.db.QueryRowContext(ctx, createPeer,
		arg.PeerID,
		arg.Disabled,
		arg.Comment,
		arg.PeerName,
		arg.PublicKey,
		arg.Interface,
		arg.AllowedAddress,
		arg.Endpoint,
		arg.EndpointPort,
		arg.PersistentKeepalive,
		arg.SchedulerID,
		arg.QueueID,
		arg.ExpireTime,
		arg.TrafficLimit,
		arg.DownloadBandwidth,
		arg.UploadBandwidth,
	)
	var i WgPeer
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.Disabled,
		&i.Comment,
		&i.PeerName,
		&i.PublicKey,
		&i.Interface,
		&i.AllowedAddress,
		&i.Endpoint,
		&i.EndpointPort,
		&i.PersistentKeepalive,
		&i.SchedulerID,
		&i.QueueID,
		&i.ExpireTime,
		&i.TrafficLimit,
		&i.DownloadBandwidth,
		&i.UploadBandwidth,
		&i.DownloadUsage,
		&i.UploadUsage,
	)
	return i, err
}

const getPeer = `-- name: GetPeer :one
SELECT id, peer_id, disabled, comment, peer_name, public_key, interface, allowed_address, endpoint, endpoint_port, persistent_keepalive, scheduler_id, queue_id, expire_time, traffic_limit, download_bandwidth, upload_bandwidth, download_usage, upload_usage FROM wg_peers
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPeer(ctx context.Context, id int64) (WgPeer, error) {
	row := q.db.QueryRowContext(ctx, getPeer, id)
	var i WgPeer
	err := row.Scan(
		&i.ID,
		&i.PeerID,
		&i.Disabled,
		&i.Comment,
		&i.PeerName,
		&i.PublicKey,
		&i.Interface,
		&i.AllowedAddress,
		&i.Endpoint,
		&i.EndpointPort,
		&i.PersistentKeepalive,
		&i.SchedulerID,
		&i.QueueID,
		&i.ExpireTime,
		&i.TrafficLimit,
		&i.DownloadBandwidth,
		&i.UploadBandwidth,
		&i.DownloadUsage,
		&i.UploadUsage,
	)
	return i, err
}

const listPeers = `-- name: ListPeers :many
SELECT id, peer_id, disabled, comment, peer_name, public_key, interface, allowed_address, endpoint, endpoint_port, persistent_keepalive, scheduler_id, queue_id, expire_time, traffic_limit, download_bandwidth, upload_bandwidth, download_usage, upload_usage FROM wg_peers
ORDER BY id
`

func (q *Queries) ListPeers(ctx context.Context) ([]WgPeer, error) {
	rows, err := q.db.QueryContext(ctx, listPeers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WgPeer
	for rows.Next() {
		var i WgPeer
		if err := rows.Scan(
			&i.ID,
			&i.PeerID,
			&i.Disabled,
			&i.Comment,
			&i.PeerName,
			&i.PublicKey,
			&i.Interface,
			&i.AllowedAddress,
			&i.Endpoint,
			&i.EndpointPort,
			&i.PersistentKeepalive,
			&i.SchedulerID,
			&i.QueueID,
			&i.ExpireTime,
			&i.TrafficLimit,
			&i.DownloadBandwidth,
			&i.UploadBandwidth,
			&i.DownloadUsage,
			&i.UploadUsage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
